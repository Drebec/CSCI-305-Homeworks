Drew Beck
Homework 6

Cost Models
1.	A[i] would be found using the equation base + (size * i)
2.	A[i][j][k] would be found using the equation base + (k * size) + (j * p * size) + (i * m * n * size)

Concurrency
1.	The three levels of concurrency in programs are the machine instruction level, the high-level language system level, and the unit level.
2.	MIMD machines utilize multiple processing cores acting asynchronously in parallel on instructions. Sometimes these instructions are completely independent of each other.
3a.	Synchronization is the process by which the ordering of execution of tasks is controlled. There are two kinds of synchronization, cooperation synchronization and competition synchronization.
3b.	Deadlock happens when all tasks running concurrently lose their liveness. Liveness is a quality a particular task may have which is an indication of that threads ability to eventually finish execution. When deadlock is reached, the program will not be able to continue as no task will posess the ability to complete its execution.
3c.	A race condition occurs when two threads or tasks attempt to access the same shared data at the same time. This access then essentially becomes a "race" between the threads to complete their operation on the shared data. Source: https://stackoverflow.com/questions/34510/what-is-a-race-condition.
4.	When deadlock is detected in a system, there are a few options the system can take to attempt to break the deadlock. These options depend heavily on the type of deadlock the system reached, the number of threads involved in the deadlock, the type of operations those threads were performing when deadlock was reached, and the type of data being manipulated when deadlock was reached. The best action for a system in deadlock to take is therefore not always the same because not all deadlocks are created equal. One good option in database systems is to attempt to undo the actions taken by one of the deadlocked threads, this allows the other thread or threads to continue while hopefully preserving the data the undone thread was working on. Source: http://www.cs.utexas.edu/users/dahlin/Classes/UGOS/lectures/lec11.pdf. Another good option would be to send an interrupt to the threads which are deadlocked, in an attempt to push them to a state which will allow them to free themselves from the lock. Kill all deadlocked threads is also an option, but a drastic one, which could also lead to data loss or corruption. Source: https://stackoverflow.com/questions/10157774/what-are-the-actions-a-system-can-take-when-a-deadlock-is-detected.
5.	Java uses the Lock interface to support explicit locks. These locks are obtained through the lock() method, and held by a thread until they are unlocked(). When a thread obtains a lock and another thread attempts to obtain the same lock after, the second thread will halt its execution until the lock is released by the first thread. The second thread then obtains the lock and is allowed to continue its execution. There are a few types of locks in Java, like ReentrantLocks and ReadWriteLocks, and they all have specific applications where the particular type of lock is more useful. Some versions of Java also support semaphores. Source: http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/.